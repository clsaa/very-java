# 9.åŒæ­¥çŠ¶æ€çš„è·å–ä¸é‡Šæ”¾

AQS çš„è®¾è®¡æ¨¡å¼é‡‡ç”¨çš„æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Œå­ç±»é€šè¿‡ç»§æ‰¿çš„æ–¹å¼ï¼Œå®ç°å®ƒçš„æŠ½è±¡æ–¹æ³•æ¥ç®¡ç†åŒæ­¥çŠ¶æ€ã€‚å¯¹äºå­ç±»è€Œè¨€ï¼Œå®ƒå¹¶æ²¡æœ‰å¤ªå¤šçš„æ´»è¦åšï¼ŒAQS å·²ç»æä¾›äº†å¤§é‡çš„æ¨¡æ¿æ–¹æ³•æ¥å®ç°åŒæ­¥ï¼Œä¸»è¦æ˜¯åˆ†ä¸ºä¸‰ç±»ï¼š

* ç‹¬å å¼è·å–å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€
* å…±äº«å¼è·å–å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€
* æŸ¥è¯¢åŒæ­¥é˜Ÿåˆ—ä¸­çš„ç­‰å¾…çº¿ç¨‹æƒ…å†µã€‚

è‡ªå®šä¹‰å­ç±»ä½¿ç”¨ AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼Œå°±å¯ä»¥å®ç°è‡ªå·±çš„åŒæ­¥è¯­ä¹‰ã€‚

## 1.ç‹¬å å¼

ç‹¬å å¼ï¼ŒåŒä¸€æ—¶åˆ»ï¼Œä»…æœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰åŒæ­¥çŠ¶æ€ã€‚

### 1.1.ç‹¬å å¼åŒæ­¥çŠ¶æ€è·å–

* Thread.currentThread().interrupt():ä¸­æ–­æ­¤çº¿ç¨‹,é™¤éå½“å‰çº¿ç¨‹æ­£åœ¨ä¸­æ–­è‡ªèº«,å¦åˆ™å°†checkAccessè°ƒç”¨æ­¤çº¿ç¨‹çš„æ–¹æ³•,è¿™å¯èƒ½ä¼šå¯¼è‡´SecurityExceptionæŠ›å‡ºè¯¥çº¿ç¨‹.å…¶ä½œç”¨æ˜¯ä¸­æ–­æ­¤çº¿ç¨‹ï¼ˆæ­¤çº¿ç¨‹ä¸ä¸€å®šæ˜¯å½“å‰çº¿ç¨‹ï¼Œè€Œæ˜¯æŒ‡è°ƒç”¨è¯¥æ–¹æ³•çš„Threadå®ä¾‹æ‰€ä»£è¡¨çš„çº¿ç¨‹ï¼‰ï¼Œä½†å®é™…ä¸Šåªæ˜¯ç»™çº¿ç¨‹è®¾ç½®ä¸€ä¸ªä¸­æ–­æ ‡å¿—ï¼Œçº¿ç¨‹ä»ä¼šç»§ç»­è¿è¡Œã€‚
* Thread.currentThread().interrupted():æµ‹è¯•å½“å‰çº¿ç¨‹æ˜¯å¦å·²è¢«ä¸­æ–­. æ­¤æ–¹æ³•æ¸…é™¤çº¿ç¨‹çš„ä¸­æ–­çŠ¶æ€. æ¢å¥è¯è¯´, å¦‚æœè¿ç»­è°ƒç”¨æ­¤æ–¹æ³•,åˆ™ç¬¬äºŒæ¬¡è°ƒç”¨å°†è¿”å›false(é™¤éå½“å‰çº¿ç¨‹åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨å·²æ¸…é™¤å…¶ä¸­çŠ¶æ€ä¹‹åä¸”åœ¨ç¬¬äºŒæ¬¡è°ƒç”¨æ£€æŸ¥ä¹‹å‰å†æ¬¡ä¸­æ–­). çº¿ç¨‹ä¸­æ–­è¢«å¿½ç•¥, å› ä¸ºåœ¨ä¸­æ–­æ—¶çº¿ç¨‹ä¸æ´»åŠ¨å°†è¢«æ­¤æ–¹æ³•ååº”è¿”å›false. è¿”å›:trueå¦‚æœå½“å‰çº¿ç¨‹å·²è¢«ä¸­æ–­; falseé™¤æ­¤ä»¥å¤–.ä½œç”¨æ˜¯æµ‹è¯•å½“å‰çº¿ç¨‹æ˜¯å¦è¢«ä¸­æ–­ï¼ˆæ£€æŸ¥ä¸­æ–­æ ‡å¿—ï¼‰ï¼Œè¿”å›ä¸€ä¸ªbooleanå¹¶æ¸…é™¤ä¸­æ–­çŠ¶æ€ï¼Œç¬¬äºŒæ¬¡å†è°ƒç”¨æ—¶ä¸­æ–­çŠ¶æ€å·²ç»è¢«æ¸…é™¤ï¼Œå°†è¿”å›ä¸€ä¸ªfalseã€‚
* Thread.currentThread().isInterrupted():æµ‹è¯•æ­¤çº¿ç¨‹æ˜¯å¦å·²è¢«ä¸­æ–­. çº¿ç¨‹çš„ä¸­æ–­çŠ¶æ€ä¸å—æ­¤æ–¹æ³•å½±å“. çº¿ç¨‹ä¸­æ–­è¢«å¿½ç•¥, å› ä¸ºåœ¨ä¸­æ–­æ—¶çº¿ç¨‹ä¸æ´»åŠ¨å°†è¢«æ­¤æ–¹æ³•åæ˜ è¿”å›false. trueå¦‚æœè¿™ä¸ªçº¿ç¨‹è¢«ä¸­æ–­äº†; falseé™¤æ­¤ä»¥å¤–.ä½œç”¨æ˜¯åªæµ‹è¯•æ­¤çº¿ç¨‹æ˜¯å¦è¢«ä¸­æ–­ ï¼Œä¸æ¸…é™¤ä¸­æ–­çŠ¶æ€ã€‚

* #acquire(int arg) æ–¹æ³•ï¼Œä¸º AQS æä¾›çš„æ¨¡æ¿æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¸ºç‹¬å å¼è·å–åŒæ­¥çŠ¶æ€ï¼Œä½†æ˜¯è¯¥æ–¹æ³•å¯¹ä¸­æ–­ä¸æ•æ„Ÿã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç”±äºçº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€å¤±è´¥è€ŒåŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œåç»­å¯¹è¯¥çº¿ç¨‹è¿›è¡Œä¸­æ–­æ“ä½œæ—¶ï¼Œçº¿ç¨‹ä¸ä¼šä» CLH åŒæ­¥é˜Ÿåˆ—ä¸­ç§»é™¤ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

ç¬¬ 2 è¡Œï¼šè°ƒç”¨ #tryAcquire(int arg) æ–¹æ³•ï¼Œå»å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚è‹¥è·å–æˆåŠŸï¼Œ#acquire(int arg) æ–¹æ³•ï¼Œç›´æ¥è¿”å›ï¼Œä¸ç”¨çº¿ç¨‹é˜»å¡ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚

* #tryAcquire(int arg) æ–¹æ³•ï¼Œéœ€è¦è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶è‡ªå·±å®ç°ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯çº¿ç¨‹å®‰å…¨çš„è·å–åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
```

* ç›´æ¥æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚
* ç¬¬ 3 è¡Œï¼šå¦‚æœ #tryAcquire(int arg) æ–¹æ³•è¿”å› false ï¼Œå³è·å–åŒæ­¥çŠ¶æ€å¤±è´¥ï¼Œåˆ™è°ƒç”¨ #addWaiter(Node mode) æ–¹æ³•ï¼Œå°†å½“å‰çº¿ç¨‹åŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—å°¾éƒ¨ã€‚å¹¶ä¸”ï¼Œ mode æ–¹æ³•å‚æ•°ä¸º Node.EXCLUSIVE ï¼Œè¡¨ç¤ºç‹¬å æ¨¡å¼ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ boolean #acquireQueued(Node node, int arg) æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚è¯¦ç»†è§£æï¼Œè§ ã€Œ1.1.1 acquireQueuedã€ ä¸­ã€‚å¦å¤–ï¼Œè¯¥æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ä¸º boolean ï¼Œå½“è¿”å› true æ—¶ï¼Œè¡¨ç¤ºåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå‘ç”Ÿè¿‡çº¿ç¨‹ä¸­æ–­ã€‚ä½†æ˜¯å‘¢ï¼Œè¿™ä¸ªæ–¹æ³•åˆä¼šæ¸…ç†çº¿ç¨‹ä¸­æ–­çš„æ ‡è¯†ï¼Œæ‰€ä»¥åœ¨ç§æƒ…å†µä¸‹ï¼Œéœ€è¦è°ƒç”¨ã€ç¬¬ 4 è¡Œã€‘çš„ #selfInterrupt() æ–¹æ³•ï¼Œæ¢å¤çº¿ç¨‹ä¸­æ–­çš„æ ‡è¯†ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```

#### 1.1.1.acquireQueued

boolean #acquireQueued(Node node, int arg) æ–¹æ³•ï¼Œä¸ºä¸€ä¸ªè‡ªæ—‹çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‰çº¿ç¨‹ï¼ˆNodeï¼‰è¿›å…¥åŒæ­¥é˜Ÿåˆ—åï¼Œå°±ä¼šè¿›å…¥ä¸€ä¸ªè‡ªæ—‹çš„è¿‡ç¨‹ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šè‡ªçœåœ°è§‚å¯Ÿï¼Œå½“æ¡ä»¶æ»¡è¶³ï¼Œè·å–åˆ°åŒæ­¥çŠ¶æ€åï¼Œå°±å¯ä»¥ä»è¿™ä¸ªè‡ªæ—‹è¿‡ç¨‹ä¸­é€€å‡ºï¼Œå¦åˆ™ä¼šä¸€ç›´æ‰§è¡Œä¸‹å»ã€‚

æµç¨‹å›¾å¦‚ä¸‹ï¼š

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-15-033940.png)

```java
final boolean acquireQueued(final Node node, int arg) {
    // è®°å½•æ˜¯å¦è·å–åŒæ­¥çŠ¶æ€æˆåŠŸ
    boolean failed = true;
    try {
        // è®°å½•è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿçº¿ç¨‹ä¸­æ–­
        boolean interrupted = false;
        /*
         * è‡ªæ—‹è¿‡ç¨‹ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªæ­»å¾ªç¯è€Œå·²
         */
        for (;;) {
            // å½“å‰çº¿ç¨‹çš„å‰é©±èŠ‚ç‚¹
            final Node p = node.predecessor();
            // å½“å‰çº¿ç¨‹çš„å‰é©±èŠ‚ç‚¹æ˜¯å¤´ç»“ç‚¹ï¼Œä¸”åŒæ­¥çŠ¶æ€æˆåŠŸ
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // è·å–å¤±è´¥ï¼Œçº¿ç¨‹ç­‰å¾…--å…·ä½“åé¢ä»‹ç»
            if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                interrupted = true;
        }   
    } finally {
        // è·å–åŒæ­¥çŠ¶æ€å‘ç”Ÿå¼‚å¸¸ï¼Œå–æ¶ˆè·å–ã€‚
        if (failed)
            cancelAcquire(node);
    }
}
```

* ç¬¬ 3 è¡Œï¼šfailed å˜é‡ï¼Œè®°å½•æ˜¯å¦è·å–åŒæ­¥çŠ¶æ€æˆåŠŸã€‚
* ç¬¬ 6 è¡Œï¼šinterrupted å˜é‡ï¼Œè®°å½•è·å–è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿçº¿ç¨‹ä¸­æ–­ã€‚

========== ç¬¬ 7 è‡³ 24 è¡Œï¼šâ€œæ­»â€å¾ªç¯ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚==========

* ç¬¬ 12 è¡Œï¼šè°ƒç”¨ Node#predecessor() æ–¹æ³•ï¼Œè·å¾—å½“å‰çº¿ç¨‹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ p ã€‚
* ç¬¬ 14 è¡Œï¼šp == head ä»£ç å—ï¼Œè‹¥æ»¡è¶³ï¼Œåˆ™è¡¨ç¤ºå½“å‰çº¿ç¨‹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå¤´èŠ‚ç‚¹ï¼Œå› ä¸º head æ˜¯æœ€åä¸€ä¸ªè·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸçš„èŠ‚ç‚¹ï¼Œæ­¤æ—¶è°ƒç”¨ #tryAcquire(int arg) æ–¹æ³•ï¼Œå°è¯•è·å¾—åŒæ­¥çŠ¶æ€ã€‚åœ¨ #acquire(int arg) æ–¹æ³•çš„ã€ç¬¬ 2 è¡Œã€‘ï¼Œä¹Ÿè°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚
* ç¬¬ 15 è‡³ 18 è¡Œï¼šå½“å‰èŠ‚ç‚¹( çº¿ç¨‹ )è·å–åŒæ­¥çŠ¶æ€æˆåŠŸï¼š
  * ç¬¬ 15 è¡Œï¼šè®¾ç½®å½“å‰èŠ‚ç‚¹( çº¿ç¨‹ )ä¸ºæ–°çš„ head ã€‚
  * ç¬¬ 16 è¡Œï¼šè®¾ç½®è€çš„å¤´èŠ‚ç‚¹ p ä¸å†æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®©å®ƒè‡ªèº«æ›´å¿«çš„è¢« GC ã€‚
  * ç¬¬ 17 è¡Œï¼šæ ‡è®° failed = false ï¼Œè¡¨ç¤ºè·å–åŒæ­¥çŠ¶æ€æˆåŠŸã€‚
  * ç¬¬ 18 è¡Œï¼šè¿”å›è®°å½•è·å–è¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦å‘ç”Ÿçº¿ç¨‹ä¸­æ–­ã€‚
* ç¬¬ 20 è‡³ 24 è¡Œï¼šè·å–å¤±è´¥ï¼Œçº¿ç¨‹ç­‰å¾…å”¤é†’ï¼Œä»è€Œè¿›è¡Œä¸‹ä¸€æ¬¡çš„åŒæ­¥çŠ¶æ€è·å–çš„å°è¯•ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹ è¯¦ç»†è§£æï¼Œè§ ã€Œ1.1.2 shouldParkAfterFailedAcquireã€ ã€‚
  * ç¬¬ 21 è¡Œï¼šè°ƒç”¨ #shouldParkAfterFailedAcquire(Node pre, Node node) æ–¹æ³•ï¼Œåˆ¤æ–­è·å–å¤±è´¥åï¼Œæ˜¯å¦å½“å‰çº¿ç¨‹éœ€è¦é˜»å¡ç­‰å¾…ã€‚

========== ç¬¬ 26 è‡³ 29 è¡Œï¼šè·å–åŒæ­¥çŠ¶æ€çš„è¿‡ç¨‹ä¸­ï¼Œå‘ç”Ÿå¼‚å¸¸ï¼Œå–æ¶ˆè·å–ã€‚==========

* ç¬¬ 28 è¡Œï¼šè°ƒç”¨ #cancelAcquire(Node node) æ–¹æ³•ï¼Œå–æ¶ˆè·å–åŒæ­¥çŠ¶æ€ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Œ1.1.3 cancelAcquireã€ ã€‚

#### 1.1.2.shouldParkAfterFailedAcquire

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    // è·å¾—å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) //  Node.SIGNAL
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
    if (ws > 0) { // Node.CANCEL
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else { // 0 æˆ–è€… Node.PROPAGATE
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

* pred å’Œ node æ–¹æ³•å‚æ•°ï¼Œä¼ å…¥æ—¶ï¼Œè¦æ±‚å‰è€…å¿…é¡»æ˜¯åè€…çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚
* ç¬¬ 3 è¡Œï¼šè·å¾—å‰ä¸€ä¸ªèŠ‚ç‚¹( pre )çš„ç­‰å¾…çŠ¶æ€ã€‚ä¸‹é¢ä¼šæ ¹æ®è¿™ä¸ªçŠ¶æ€æœ‰ä¸‰ç§æƒ…å†µçš„å¤„ç†ã€‚
* ç¬¬ 4 è‡³ 9 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º Node.SIGNAL æ—¶ï¼Œè¡¨ç¤º pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ node çš„çº¿ç¨‹éœ€è¦é˜»å¡ç­‰å¾…ã€‚åœ¨ pred çš„çº¿ç¨‹é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶ï¼Œä¼šå¯¹ node çš„çº¿ç¨‹è¿›è¡Œå”¤é†’é€šçŸ¥ã€‚æ‰€ä»¥ï¼Œã€ç¬¬ 9 è¡Œã€‘è¿”å› true ï¼Œè¡¨æ˜å½“å‰çº¿ç¨‹å¯ä»¥è¢« parkï¼Œå®‰å…¨çš„é˜»å¡ç­‰å¾…ã€‚
* ç¬¬ 19 è‡³ 26 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º 0 æˆ–è€… Node.PROPAGATE æ—¶ï¼Œé€šè¿‡ CAS è®¾ç½®ï¼Œå°†çŠ¶æ€ä¿®æ”¹ä¸º Node.SIGNAL ï¼Œå³ä¸‹ä¸€æ¬¡é‡æ–°æ‰§è¡Œ #shouldParkAfterFailedAcquire(Node pred, Node node) æ–¹æ³•æ—¶ï¼Œæ»¡è¶³ã€ç¬¬ 4 è‡³ 9 è¡Œã€‘çš„æ¡ä»¶ã€‚
  * ä½†æ˜¯ï¼Œå¯¹äºæœ¬æ¬¡æ‰§è¡Œï¼Œã€ç¬¬ 27 è¡Œã€‘è¿”å› false ã€‚
  * å¦å¤–ï¼Œç­‰å¾…çŠ¶æ€ä¸ä¼šä¸º Node.CONDITION ï¼Œå› ä¸ºå®ƒç”¨åœ¨ ConditonObject ä¸­ã€‚
* ç¬¬ 10 è‡³ 18 è¡Œï¼šç­‰å¾…çŠ¶æ€ä¸º NODE.CANCELLED æ—¶ï¼Œåˆ™è¡¨æ˜è¯¥çº¿ç¨‹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹å·²ç»ç­‰å¾…è¶…æ—¶æˆ–è€…è¢«ä¸­æ–­äº†ï¼Œåˆ™éœ€è¦ä» CLH é˜Ÿåˆ—ä¸­å°†è¯¥å‰ä¸€ä¸ªèŠ‚ç‚¹åˆ é™¤æ‰ï¼Œå¾ªç¯å›æº¯ï¼Œç›´åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹çŠ¶æ€ <= 0 ã€‚
  * å¯¹äºæœ¬æ¬¡æ‰§è¡Œï¼Œã€ç¬¬ 27 è¡Œã€‘è¿”å› false ï¼Œéœ€è¦ä¸‹ä¸€æ¬¡å†é‡æ–°æ‰§è¡Œ #shouldParkAfterFailedAcquire(Node pred, Node node) æ–¹æ³•ï¼Œçœ‹çœ‹æ»¡è¶³å“ªä¸ªæ¡ä»¶ã€‚
  * æ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾ï¼š

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-15-084755.png)

#### 1.1.3.cancelAcquire

```java
private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus > 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail && compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &&
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
            pred.thread != null) {
            Node next = node.next;
            if (next != null && next.waitStatus <= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
```

* ç¬¬ 2 è‡³ 4 è¡Œï¼šå¿½ç•¥ï¼Œè‹¥ä¼ å…¥å‚æ•° node ä¸ºç©ºã€‚
* ç¬¬ 6 è¡Œï¼šå°†èŠ‚ç‚¹çš„ç­‰å¾…çº¿ç¨‹ç½®ç©ºã€‚
* ç¬¬ 9 è¡Œï¼šè·å¾— node èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ pred ã€‚
  * ç¬¬ 10 è‡³ 11 è¡Œï¼š é€»è¾‘åŒ #shouldParkAfterFailedAcquire(Node pred, Node node) çš„ã€ç¬¬ 15 è‡³ 17 è¡Œã€‘ã€‚
* ç¬¬ 16 è¡Œï¼šè·å¾— pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ predNext ã€‚åœ¨è¿™ä¸ªå˜é‡ä¸Šï¼Œæœ‰å¾ˆâ€œå¤æ‚â€çš„è‹±æ–‡ï¼Œæˆ‘ä»¬æ¥ç†è§£ä¸‹ï¼špredNext ä»è¡¨é¢ä¸Šçœ‹ï¼Œå’Œ node æ˜¯ç­‰ä»·çš„ã€‚
  * ä½†æ˜¯å®é™…ä¸Šï¼Œå­˜åœ¨å¤šçº¿ç¨‹å¹¶å‘çš„æƒ…å†µï¼Œæ‰€ä»¥åœ¨ã€ç¬¬ 25 è¡Œã€‘æˆ–è€…ã€ç¬¬ 36 è¡Œã€‘ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨ #compareAndSetNext(...) æ–¹æ³•ï¼Œä½¿ç”¨ CAS çš„æ–¹å¼ï¼Œè®¾ç½® pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
  * å¦‚æœè®¾ç½®å¤±è´¥ï¼Œè¯´æ˜å½“å‰çº¿ç¨‹å’Œå…¶å®ƒçº¿ç¨‹ç«äº‰å¤±è´¥ï¼Œä¸éœ€è¦åšå…¶å®ƒé€»è¾‘ï¼Œå› ä¸º pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å·²ç»è¢«å…¶å®ƒçº¿ç¨‹è®¾ç½®æˆåŠŸã€‚
* ç¬¬ 21 è¡Œï¼šè®¾ç½® node èŠ‚ç‚¹çš„ä¸ºå–æ¶ˆçš„ç­‰å¾…çŠ¶æ€ Node.CANCELLED ã€‚åœ¨è¿™ä¸ªå˜é‡ä¸Šï¼Œæœ‰å¾ˆâ€œå¤æ‚â€çš„è‹±æ–‡ï¼Œæˆ‘ä»¬å†æ¥ç†è§£ä¸‹ï¼š
  * è¿™é‡Œå¯ä»¥ä½¿ç”¨ç›´æ¥å†™ï¼Œè€Œä¸æ˜¯ CAS ã€‚
  * åœ¨è¿™ä¸ªæ“ä½œä¹‹åï¼Œå…¶å®ƒ Node èŠ‚ç‚¹å¯ä»¥å¿½ç•¥ node ã€‚
  * Before, we are free of interference from other threads.
* ä¸‹é¢å¼€å§‹å¼€å§‹ä¿®æ”¹ pred çš„æ–°çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€å…±åˆ†æˆä¸‰ç§æƒ…å†µã€‚

========== ç¬¬ä¸€ç§ ==========

* ç¬¬ 24 è¡Œï¼šå¦‚æœ node æ˜¯å°¾èŠ‚ç‚¹ï¼Œè°ƒç”¨ #compareAndSetTail(...) æ–¹æ³•ï¼ŒCAS è®¾ç½® pred ä¸ºæ–°çš„å°¾èŠ‚ç‚¹ã€‚
  * ç¬¬ 25 è¡Œï¼šè‹¥ä¸Šè¿°æ“ä½œæˆåŠŸï¼Œè°ƒç”¨ #compareAndSetNext(...) æ–¹æ³•ï¼ŒCAS è®¾ç½® pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º( null )ã€‚

========== ç¬¬äºŒç§ ==========
* ç¬¬ 30 è¡Œï¼špred éé¦–èŠ‚ç‚¹ã€‚
* ç¬¬ 31 è‡³ 32 è¡Œï¼špred çš„ç­‰å¾…çŠ¶æ€ä¸º Node.SIGNAL ï¼Œæˆ–è€…å¯è¢« CAS ä¸º Node.SIGNAL ã€‚
* ç¬¬ 33 è¡Œï¼špred çš„çº¿ç¨‹éç©ºã€‚
  * TODO 9001 èŠ‹è‰¿ï¼Œå¦‚ä½•ç†è§£ã€‚ç›®å‰èƒ½æƒ³è±¡åˆ°çš„ï¼Œä¸€å¼€å§‹ 30 è¡Œä¸ºéå¤´èŠ‚ç‚¹ï¼Œåœ¨ 33 çš„æ—¶å€™ï¼Œç»“æœæˆä¸ºå¤´èŠ‚ç‚¹ï¼Œçº¿ç¨‹å·²ç»ä¸ºç©ºäº†ã€‚
* ç¬¬ 34 è‡³ 36 è¡Œï¼šè‹¥ node çš„ ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ next çš„ç­‰å¾…çŠ¶æ€é Node.CANCELLED ï¼Œåˆ™è°ƒç”¨ #compareAndSetNext(...) æ–¹æ³•ï¼ŒCAS è®¾ç½® pred çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸º next

========== ç¬¬ä¸‰ç§ ==========

* ç¬¬ 37 è‡³ 39 è¡Œï¼šå¦‚æœ pred ä¸ºé¦–èŠ‚ç‚¹(  åœ¨ã€ç¬¬ 31 è‡³ 33 è¡Œã€‘ä¹Ÿä¼šæœ‰åˆ«çš„æƒ…å†µ )ï¼Œè°ƒç”¨ #unparkSuccessor(Node node) æ–¹æ³•ï¼Œå”¤é†’ node çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„çº¿ç¨‹ç­‰å¾…ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹ ã€‚
  * ä¸ºä»€ä¹ˆæ­¤å¤„éœ€è¦å”¤é†’å‘¢ï¼Ÿå› ä¸ºï¼Œpred ä¸ºé¦–èŠ‚ç‚¹ï¼Œnode çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„é˜»å¡ç­‰å¾…ï¼Œéœ€è¦ node é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶è¿›è¡Œå”¤é†’ã€‚ä½†æ˜¯ï¼Œnode å–æ¶ˆè·å–åŒæ­¥çŠ¶æ€ï¼Œåˆ™ä¸ä¼šå†å‡ºç° node é‡Šæ”¾åŒæ­¥çŠ¶æ€æ—¶è¿›è¡Œå”¤é†’ node çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚å› æ­¤ï¼Œéœ€è¦æ­¤å¤„è¿›è¡Œå”¤é†’ã€‚

========== ç¬¬ äºŒ + ä¸‰ç§ ==========
ç¬¬ 41 è¡Œï¼šTODO èŠ‹è‰¿ 9002 ä¸ºå•¥æ˜¯ next ä¸º node ã€‚ç›®å‰æ”¶é›†åˆ°çš„èµ„æ–™å¦‚ä¸‹ï¼š

### 1.2.ç‹¬å å¼è·å–å“åº”ä¸­æ–­

AQS æä¾›äº†acquire(int arg) æ–¹æ³•ï¼Œä»¥ä¾›ç‹¬å å¼è·å–åŒæ­¥çŠ¶æ€ï¼Œä½†æ˜¯è¯¥æ–¹æ³•å¯¹ä¸­æ–­ä¸å“åº”ï¼Œå¯¹çº¿ç¨‹è¿›è¡Œä¸­æ–­æ“ä½œåï¼Œè¯¥çº¿ç¨‹ä¼šä¾ç„¶ä½äºCLHåŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…ç€è·å–åŒæ­¥çŠ¶æ€ã€‚ä¸ºäº†å“åº”ä¸­æ–­ï¼ŒAQS æä¾›äº† #acquireInterruptibly(int arg) æ–¹æ³•ã€‚è¯¥æ–¹æ³•åœ¨ç­‰å¾…è·å–åŒæ­¥çŠ¶æ€æ—¶ï¼Œå¦‚æœå½“å‰çº¿ç¨‹è¢«ä¸­æ–­äº†ï¼Œä¼šç«‹åˆ»å“åº”ä¸­æ–­ï¼Œå¹¶æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚

```java
public final void acquireInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
```

* é¦–å…ˆï¼Œæ ¡éªŒè¯¥çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æŠ›å‡ºInterruptedException å¼‚å¸¸ã€‚
* ç„¶åï¼Œè°ƒç”¨ #tryAcquire(int arg) æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œå¦‚æœè·å–æˆåŠŸï¼Œåˆ™ç›´æ¥è¿”å›ã€‚
* æœ€åï¼Œè°ƒç”¨ #doAcquireInterruptibly(int arg) æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œæˆ–çº¿ç¨‹ä¸­æ–­æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
åº”è¯¥ä¸ä»…ä»… help gc

#### 1.2.1.doAcquireInterruptibly

```java
private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException(); // <1>
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

å®ƒä¸ #acquire(int arg) æ–¹æ³•ä»…æœ‰ä¸¤ä¸ªå·®åˆ«ï¼š

* æ–¹æ³•å£°æ˜æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
* åœ¨ä¸­æ–­æ–¹æ³•å¤„ä¸å†æ˜¯ä½¿ç”¨ interrupted æ ‡å¿—ï¼Œè€Œæ˜¯ç›´æ¥æŠ›å‡º InterruptedException å¼‚å¸¸ï¼Œå³ <1> å¤„ã€‚

### 1.3.ç‹¬å å¼è¶…æ—¶è·å–

AQS é™¤äº†æä¾›ä¸Šé¢ä¸¤ä¸ªæ–¹æ³•å¤–ï¼Œè¿˜æä¾›äº†ä¸€ä¸ªå¢å¼ºç‰ˆçš„æ–¹æ³• #tryAcquireNanos(int arg, long nanos) ã€‚è¯¥æ–¹æ³•ä¸º #acquireInterruptibly(int arg) æ–¹æ³•çš„è¿›ä¸€æ­¥å¢å¼ºï¼Œå®ƒé™¤äº†å“åº”ä¸­æ–­å¤–ï¼Œè¿˜æœ‰è¶…æ—¶æ§åˆ¶ã€‚å³å¦‚æœå½“å‰çº¿ç¨‹æ²¡æœ‰åœ¨æŒ‡å®šæ—¶é—´å†…è·å–åŒæ­¥çŠ¶æ€ï¼Œåˆ™ä¼šè¿”å› false ï¼Œå¦åˆ™è¿”å› true ã€‚

æµç¨‹å›¾å¦‚ä¸‹ï¼š

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-03-15-131350.png)

ä»£ç å¦‚ä¸‹ï¼š

```java
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}
```

* é¦–å…ˆï¼Œæ ¡éªŒè¯¥çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æŠ›å‡ºInterruptedException å¼‚å¸¸ã€‚
* ç„¶åï¼Œè°ƒç”¨ #tryAcquire(int arg) æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œå¦‚æœè·å–æˆåŠŸï¼Œåˆ™ç›´æ¥è¿”å›ã€‚
* æœ€åï¼Œè°ƒç”¨ #tryAcquireNanos(int arg) æ–¹æ³•ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸï¼Œæˆ–çº¿ç¨‹ä¸­æ–­æŠ›å‡º InterruptedException å¼‚å¸¸ï¼Œæˆ–è¶…è¿‡æŒ‡å®šæ—¶é—´è¿”å›è·å–åŒæ­¥çŠ¶æ€å¤±è´¥ã€‚

#### 1.3.1.tryAcquireNanos

```java
static final long spinForTimeoutThreshold = 1000L;

private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    // nanosTimeout <= 0
    if (nanosTimeout <= 0L)
        return false;
    // è¶…æ—¶æ—¶é—´
    final long deadline = System.nanoTime() + nanosTimeout;
    // æ–°å¢ Node èŠ‚ç‚¹
    final Node node = addWaiter(Node.EXCLUSIVE);
     boolean failed = true;
     try {
         // è‡ªæ—‹
         for (;;) {
             final Node p = node.predecessor();
             // è·å–åŒæ­¥çŠ¶æ€æˆåŠŸ
             if (p == head && tryAcquire(arg)) {
                 setHead(node);
                 p.next = null; // help GC
                 failed = false;
                 return true;
             }
             /*
              * è·å–å¤±è´¥ï¼Œåšè¶…æ—¶ã€ä¸­æ–­åˆ¤æ–­
              */
             // é‡æ–°è®¡ç®—éœ€è¦ä¼‘çœ çš„æ—¶é—´
             nanosTimeout = deadline - System.nanoTime();
             // å·²ç»è¶…æ—¶ï¼Œè¿”å›false
             if (nanosTimeout <= 0L)
                 return false;
             // å¦‚æœæ²¡æœ‰è¶…æ—¶ï¼Œåˆ™ç­‰å¾…nanosTimeoutçº³ç§’
             // æ³¨ï¼šè¯¥çº¿ç¨‹ä¼šç›´æ¥ä»LockSupport.parkNanosä¸­è¿”å›ï¼Œ
             // LockSupport ä¸º J.U.C æä¾›çš„ä¸€ä¸ªé˜»å¡å’Œå”¤é†’çš„å·¥å…·ç±»ï¼Œåé¢åšè¯¦ç»†ä»‹ç»
             if (shouldParkAfterFailedAcquire(p, node) &&
                     nanosTimeout > spinForTimeoutThreshold)
                 LockSupport.parkNanos(this, nanosTimeout);
             // çº¿ç¨‹æ˜¯å¦å·²ç»ä¸­æ–­äº†
             if (Thread.interrupted())
                 throw new InterruptedException();
         }
     } finally {
         if (failed)
             cancelAcquire(node);
     }
 }
```

* å› ä¸ºæ˜¯åœ¨ #doAcquireInterruptibly(int arg) æ–¹æ³•çš„åŸºç¡€ä¸Šï¼Œåšäº†è¶…æ—¶æ§åˆ¶çš„å¢å¼ºï¼Œæ‰€ä»¥ç›¸åŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡ã€‚
* ç¬¬ 3 è‡³ 5 è¡Œï¼šå¦‚æœè¶…æ—¶æ—¶é—´å°äº 0 ï¼Œç›´æ¥è¿”å› false ï¼Œå·²ç»è¶…æ—¶ã€‚
* ç¬¬ 7 è¡Œï¼šè®¡ç®—æœ€ç»ˆè¶…æ—¶æ—¶é—´ deadline ã€‚
* ç¬¬ 9 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 10 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 13 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 14 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 15 è‡³ 21 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 26 è¡Œï¼šé‡æ–°è®¡ç®—å‰©ä½™å¯è·å–åŒæ­¥çŠ¶æ€çš„æ—¶é—´ nanosTimeout ã€‚
* ç¬¬ 27 è‡³ 29 è¡Œï¼šå¦‚æœå‰©ä½™æ—¶é—´å°äº 0 ï¼Œç›´æ¥è¿”å› false ï¼Œå·²ç»è¶…æ—¶ã€‚
* ç¬¬ 33 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 34 è‡³ 35 è¡Œï¼šå¦‚æœå‰©ä½™æ—¶é—´å¤§äº spinForTimeoutThreshold ï¼Œåˆ™è°ƒç”¨ LockSupport#parkNanos(Object blocker, long nanos) æ–¹æ³•ï¼Œä¼‘çœ  nanosTimeout çº³ç§’ã€‚å¦åˆ™ï¼Œå°±ä¸éœ€è¦ä¼‘çœ äº†ï¼Œç›´æ¥è¿›å…¥å¿«é€Ÿè‡ªæ—‹çš„è¿‡ç¨‹ã€‚åŸå› åœ¨äºï¼ŒspinForTimeoutThreshold å·²ç»éå¸¸å°äº†ï¼Œéå¸¸çŸ­çš„æ—¶é—´ç­‰å¾…æ— æ³•åšåˆ°ååˆ†ç²¾ç¡®ï¼Œå¦‚æœè¿™æ—¶å†æ¬¡è¿›è¡Œè¶…æ—¶ç­‰å¾…ï¼Œç›¸åä¼šè®© nanosTimeout çš„è¶…æ—¶ä»æ•´ä½“ä¸Šé¢è¡¨ç°å¾—ä¸æ˜¯é‚£ä¹ˆç²¾ç¡®ã€‚æ‰€ä»¥ï¼Œåœ¨è¶…æ—¶éå¸¸çŸ­çš„åœºæ™¯ä¸­ï¼ŒAQS ä¼šè¿›è¡Œæ— æ¡ä»¶çš„å¿«é€Ÿè‡ªæ—‹ã€‚
* ç¬¬ 36 è‡³ 39 è¡Œï¼šè‹¥çº¿ç¨‹å·²ç»ä¸­æ–­äº†ï¼ŒæŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
* ç¬¬ 40 è‡³ 43 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘

### 1.4.ç‹¬å å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾

å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€åï¼Œæ‰§è¡Œå®Œç›¸åº”é€»è¾‘åï¼Œå°±éœ€è¦é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚AQS æä¾›äº†#release(int arg)æ–¹æ³•ï¼Œé‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ #tryRelease(int arg) æ–¹æ³•ï¼Œå»å°è¯•é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚åŒæ—¶ï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”ã€ç¬¬ 3 è‡³ 6ã€‘å’Œã€ç¬¬ 8 è¡Œã€‘çš„é€»è¾‘ã€‚
  * #tryRelease(int arg) æ–¹æ³•ï¼Œéœ€è¦è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶è‡ªå·±å®ç°ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯çº¿ç¨‹å®‰å…¨çš„é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}
```

* ç¬¬ 3 è¡Œï¼šè·å¾—å½“å‰çš„ head ï¼Œé¿å…å¹¶å‘é—®é¢˜ã€‚
* ç¬¬ 4 è¡Œï¼šå¤´ç»“ç‚¹ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å¤´ç»“ç‚¹çŠ¶æ€ä¸ä¸º 0 ( INITAL æœªåˆå§‹åŒ–)ã€‚ä¸ºä»€ä¹ˆä¼šå‡ºç° 0 çš„æƒ…å†µå‘¢ï¼Ÿä»¥ ReentrantReadWriteLock ( å†…éƒ¨åŸºäº AQS å®ç° ) ä¸¾ä¾‹å­ï¼š
  * çº¿ç¨‹ A å’Œçº¿ç¨‹ B ï¼Œéƒ½è·å–äº†è¯»é”ã€‚
* ç¬¬ 5 è¡Œï¼šè°ƒç”¨ #unparkSuccessor(Node node) æ–¹æ³•ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„çº¿ç¨‹ç­‰å¾…ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Šã€æ­»ç£• Java å¹¶å‘ã€‘â€”â€“ J.U.C ä¹‹ AQSï¼šé˜»å¡å’Œå”¤é†’çº¿ç¨‹ã€‹ ã€‚

### 1.5.æ€»ç»“

* åœ¨ AQS ä¸­ç»´æŠ¤ç€ä¸€ä¸ª FIFO çš„åŒæ­¥é˜Ÿåˆ—ã€‚
  * å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€å¤±è´¥åï¼Œåˆ™ä¼šåŠ å…¥åˆ°è¿™ä¸ª CLH åŒæ­¥é˜Ÿåˆ—çš„å¯¹å°¾ï¼Œå¹¶ä¸€ç›´ä¿æŒç€è‡ªæ—‹ã€‚
  * åœ¨ CLH åŒæ­¥é˜Ÿåˆ—ä¸­çš„çº¿ç¨‹åœ¨è‡ªæ—‹æ—¶ï¼Œä¼šåˆ¤æ–­å…¶å‰é©±èŠ‚ç‚¹æ˜¯å¦ä¸ºé¦–èŠ‚ç‚¹ï¼Œå¦‚æœä¸ºé¦–èŠ‚ç‚¹åˆ™ä¸æ–­å°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™é€€å‡ºCLHåŒæ­¥é˜Ÿåˆ—ã€‚
  * å½“çº¿ç¨‹æ‰§è¡Œå®Œé€»è¾‘åï¼Œä¼šé‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾åä¼šå”¤é†’å…¶åç»§èŠ‚ç‚¹ã€‚

## 2.å…±äº«å¼

* å…±äº«å¼ä¸ç‹¬å å¼çš„æœ€ä¸»è¦åŒºåˆ«åœ¨äºï¼ŒåŒä¸€æ—¶åˆ»ï¼š
  * ç‹¬å å¼åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€ã€‚
  * å…±äº«å¼å¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€ã€‚

ä¾‹å¦‚ï¼Œè¯»æ“ä½œå¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶è¿›è¡Œï¼Œè€Œå†™æ“ä½œåŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œå†™æ“ä½œï¼Œå…¶ä»–æ“ä½œéƒ½ä¼šè¢«é˜»å¡ã€‚å‚è§ ReentrantReadWriteLock ã€‚

### 2.1.å…±äº«å¼åŒæ­¥çŠ¶æ€è·å–

* #acquireShared(int arg) æ–¹æ³•ï¼Œå¯¹æ ‡ #acquire(int arg) æ–¹æ³•ã€‚

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

* ç¬¬ 2 è¡Œï¼šè°ƒç”¨ #tryAcquireShared(int arg) æ–¹æ³•ï¼Œå°è¯•è·å–åŒæ­¥çŠ¶æ€ï¼Œè·å–æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å›å¤§äºç­‰äº 0 ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å›å°äº 0 ã€‚è‹¥è·å–æˆåŠŸï¼Œç›´æ¥è¿”å›ï¼Œä¸ç”¨çº¿ç¨‹é˜»å¡ï¼Œè‡ªæ—‹ç›´åˆ°è·å¾—åŒæ­¥çŠ¶æ€æˆåŠŸã€‚
* #tryAcquireShared(int arg) æ–¹æ³•ï¼Œéœ€è¦è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶è‡ªå·±å®ç°ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯çº¿ç¨‹å®‰å…¨çš„è·å–åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}
```

* ç›´æ¥æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

###2.1.å…±äº«å¼åŒæ­¥çŠ¶æ€è·å–

#### 2.1.1.doAcquireShared

```java
private void doAcquireShared(int arg) {
    // å…±äº«å¼èŠ‚ç‚¹
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // å‰é©±èŠ‚ç‚¹
            final Node p = node.predecessor();
            // å¦‚æœå…¶å‰é©±èŠ‚ç‚¹ï¼Œè·å–åŒæ­¥çŠ¶æ€
            if (p == head) {
                // å°è¯•è·å–åŒæ­¥
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

* å› ä¸ºå’Œ #acquireQueued(int arg) æ–¹æ³•çš„åŸºç¡€ä¸Šï¼Œæ‰€ä»¥ç›¸åŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬ç›´æ¥è·³è¿‡ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ #addWaiter(Node mode) æ–¹æ³•ï¼Œå°†å½“å‰çº¿ç¨‹åŠ å…¥åˆ° CLH åŒæ­¥é˜Ÿåˆ—å°¾éƒ¨ã€‚å¹¶ä¸”ï¼Œ mode æ–¹æ³•å‚æ•°ä¸º Node.SHARED ï¼Œè¡¨ç¤ºå…±äº«æ¨¡å¼ã€‚
* ç¬¬ 6 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 9 è‡³ 22 è¡Œï¼šã€å¤§ä½“ç›¸åŒï¼Œéƒ¨åˆ†è·³è¿‡ã€‘
  * ç¬¬ 13 è¡Œï¼šè°ƒç”¨ #tryAcquireShared(int arg) æ–¹æ³•ï¼Œå°è¯•è·å¾—åŒæ­¥çŠ¶æ€ã€‚ğŸ™‚ åœ¨ #acquireShared(int arg) æ–¹æ³•çš„ã€ç¬¬ 2 è¡Œã€‘ï¼Œä¹Ÿè°ƒç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚
  * ç¬¬ 15 è¡Œï¼šè°ƒç”¨ #setHeadAndPropagate(Node node, int propagate) æ–¹æ³•ï¼Œè®¾ç½®æ–°çš„é¦–èŠ‚ç‚¹ï¼Œå¹¶æ ¹æ®æ¡ä»¶ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Œ2.1.2 setHeadAndPropagateã€ ã€‚
    * è¿™é‡Œå’Œç‹¬å å¼åŒæ­¥çŠ¶æ€è·å–å¾ˆå¤§çš„ä¸åŒï¼šé€šè¿‡è¿™æ ·çš„æ–¹å¼ï¼Œä¸æ–­å”¤é†’ä¸‹ä¸€ä¸ªå…±äº«å¼åŒæ­¥çŠ¶æ€ï¼Œ ä»è€Œå®ç°åŒæ­¥çŠ¶æ€è¢«å¤šä¸ªçº¿ç¨‹çš„å…±äº«è·å–ã€‚
    * ç¬¬ 17 è‡³ 18 è¡Œï¼šå’Œ #acquire(int arg) æ–¹æ³•ï¼Œå¯¹äºçº¿ç¨‹ä¸­æ–­çš„å¤„ç†æ–¹å¼ç›¸åŒï¼Œåªæ˜¯ä»£ç æ”¾ç½®çš„ä½ç½®ä¸åŒ
* ç¬¬ 23 è‡³ 25 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘
* ç¬¬ 27 è‡³ 30 è¡Œï¼šã€ç›¸åŒï¼Œè·³è¿‡ã€‘

#### 2.1.2 setHeadAndPropagate

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

* ç¬¬ 2 è¡Œï¼šè®°å½•åŸæ¥çš„é¦–èŠ‚ç‚¹ h ã€‚
* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ #setHead(Node node) æ–¹æ³•ï¼Œè®¾ç½® node ä¸ºæ–°çš„é¦–èŠ‚ç‚¹ã€‚
* ç¬¬ 20 è¡Œï¼špropagate > 0 ä»£ç å—ï¼Œè¯´æ˜åŒæ­¥çŠ¶æ€è¿˜èƒ½è¢«å…¶ä»–çº¿ç¨‹è·å–ã€‚
* ç¬¬ 20 è‡³ 21 è¡Œï¼šåˆ¤æ–­åŸæ¥çš„æˆ–è€…æ–°çš„é¦–èŠ‚ç‚¹ï¼Œç­‰å¾…çŠ¶æ€ä¸º Node.PROPAGATE æˆ–è€… Node.SIGNAL æ—¶ï¼Œå¯ä»¥ç»§ç»­å‘ä¸‹å”¤é†’ã€‚
* ç¬¬ 23 è¡Œï¼šè°ƒç”¨ Node#isShared() æ–¹æ³•ï¼Œåˆ¤æ–­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºå…±äº«å¼è·å–åŒæ­¥çŠ¶æ€ã€‚
* ç¬¬ 24 è¡Œï¼šè°ƒç”¨ #doReleaseShared() æ–¹æ³•ï¼Œå”¤é†’åç»­çš„å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ã€‚è¯¦ç»†è§£æï¼Œè§ ã€Œ2.1.2 setHeadAndPropagateã€ ã€‚

### 2.2.å…±äº«å¼è·å–å“åº”ä¸­æ–­

* #acquireSharedInterruptibly(int arg) æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}

private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

* ä¸ ã€Œ1.2 ç‹¬å å¼è·å–å“åº”ä¸­æ–­ã€ ç±»ä¼¼ï¼Œå°±ä¸é‡å¤è§£æäº†ã€‚


### 2.3.å…±äº«å¼è¶…æ—¶è·å–

* #tryAcquireSharedNanos(int arg, long nanosTimeout) æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) >= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
}

private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout <= 0L)
        return false;
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
            }
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout <= 0L)
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

* ä¸ ã€Œ1.3 ç‹¬å å¼è¶…æ—¶è·å–ã€ ç±»ä¼¼ï¼Œå°±ä¸é‡å¤è§£æäº†ã€‚

### 2.4.å…±äº«å¼åŒæ­¥çŠ¶æ€é‡Šæ”¾

å½“çº¿ç¨‹è·å–åŒæ­¥çŠ¶æ€åï¼Œæ‰§è¡Œå®Œç›¸åº”é€»è¾‘åï¼Œå°±éœ€è¦é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚AQS æä¾›äº†#releaseShared(int arg)æ–¹æ³•ï¼Œé‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼š

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

ç¬¬ 2 è¡Œï¼šè°ƒç”¨ #tryReleaseShared(int arg) æ–¹æ³•ï¼Œå»å°è¯•é‡Šæ”¾åŒæ­¥çŠ¶æ€ï¼Œé‡Šæ”¾æˆåŠŸåˆ™è®¾ç½®é”çŠ¶æ€å¹¶è¿”å› true ï¼Œå¦åˆ™è·å–å¤±è´¥ï¼Œè¿”å› false ã€‚åŒæ—¶ï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”ã€ç¬¬ 3 è‡³ 5ã€‘å’Œã€ç¬¬ 6 è¡Œã€‘çš„é€»è¾‘ã€‚

* #tryReleaseShared(int arg) æ–¹æ³•ï¼Œéœ€è¦è‡ªå®šä¹‰åŒæ­¥ç»„ä»¶è‡ªå·±å®ç°ï¼Œè¯¥æ–¹æ³•å¿…é¡»è¦ä¿è¯çº¿ç¨‹å®‰å…¨çš„é‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚ä»£ç å¦‚ä¸‹ï¼šç›´æ¥æŠ›å‡º UnsupportedOperationException å¼‚å¸¸ã€‚

```java
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}
```

* ç¬¬ 3 è¡Œï¼šè°ƒç”¨ #doReleaseShared() æ–¹æ³•ï¼Œå”¤é†’åç»­çš„å…±äº«å¼è·å–åŒæ­¥çŠ¶æ€çš„èŠ‚ç‚¹ã€‚

### 2.4.1.doReleaseShared

```java
private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        // é˜Ÿåˆ—ä¸ä¸ºç©ºä¸”æœ‰åç»§ç»“ç‚¹
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            // ä¸ç®¡æ˜¯å…±äº«è¿˜æ˜¯ç‹¬å åªæœ‰ç»“ç‚¹çŠ¶æ€ä¸ºSIGNALæ‰å°è¯•å”¤é†’åç»§ç»“ç‚¹
            if (ws == Node.SIGNAL) {
                // å°†waitStatusè®¾ç½®ä¸º0
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue; // loop to recheck cases
                unparkSuccessor(h);// å”¤é†’åç»§ç»“ç‚¹
                // å¦‚æœçŠ¶æ€ä¸º0åˆ™æ›´æ–°çŠ¶æ€ä¸ºPROPAGATEï¼Œæ›´æ–°å¤±è´¥åˆ™é‡è¯•
            } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue; // loop on failed CAS
        }
        // å¦‚æœè¿‡ç¨‹ä¸­headè¢«ä¿®æ”¹äº†åˆ™é‡è¯•ã€‚
        if (h == head) // loop if head changed
            break;
    }
}
```

## 2.5.å‚è€ƒ

<http://zhanjindong.com/2015/03/15/java-concurrent-package-aqs-AbstractQueuedSynchronizer>
<http://www.iocoder.cn/JUC/sike/aqs-2/>