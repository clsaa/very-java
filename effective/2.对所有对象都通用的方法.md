# 2.对所有对象都通用的方法

## 2.1.equals方法

覆盖equals，方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与它自身相等。

如果满足了以下任何一个条件，这就正是所期望的结果：

* 类的每个实例本质上都是唯一的
* 不关心类是否提供了“逻辑相等（logical equality)“的测试功能
* 超类已经覆盖了 equals，从超类继承过来的行为对于子类也是合适的
* 类是私有的或是包级私有的，可以确定它的 equals 方法永远不会被调用

那么，什么时候应该覆盖 Object. Equals 呢？如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖 equals 以实现期望的行为，这时我们就需要覆盖 equals 方法。这通常属于“值类（value class）”的情形。值类仅仅是一个表示值的类，例如 Integer 或者 Date。

在覆盖 equals 方法的时候，你必须要遵守它的通用约定：

* 自反性（reflexive）。对于任何非 null 的引用值 x，x. Equals (x）必须返回 true.
* 对称性（symmetric）。对于任何非 null 的引用值 x 和 y，当且仅当 y. Equals (x）返回 true 时，x. Equals (y）必须返回 true。
* 传递性（transitive）。对于任何非 nul1 的引用值 x. Y 和 z，如果 x. Equals (y）返回 true，并且 y. Cquals (z）也返回 true，那么 x. Equals (z）也必须返回 true。
* 一致性（consistent）。对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x equals (y）就会一致地返回 true，或者一致地返回 false。

* 对称性的例子

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-191429.png)

在这个类中，equals 方法的意图非常好，它企图与普通的字符串（String）对象进行互操作。假设我们有一个不区分大小写的字符串和一个普通的字符串。

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-191641.png)

正如所料，cis. Equals (s）返回 true。问题在于，虽然 CaseInsensitiveString 类中的 equals 方法知道普通的字符串（String）对象，但是，String 类中的 equals 方法却并不知道不区分大小写的字符串。

* 传递性的例子

传递性（transitivity) equals 约定的第三个要求是，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。同样地，无意识地违反这条规则的情形也不难想像。考虑子类的情形，它将一个新的值组件，（value component）添加到了超类中。换句话说，子类增加的信息会影响到 equals 的比较结果。我们首先以一个简单的不可变的二维整数型 Point 类作为开始：

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-191809.png)

假设你想要扩展这个类，为一个点添加颜色信息：

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-191858.png)

Equals 方法会怎么样呢？如果完全不提供 cquals 方法，而是直接从 Point 继承过来，在 equals 做比较的时候颜色信息就被忽略掉了。虽然这样做不会违反 equals 约定，但是很明显这不符合要求。假如我们用如下的方法：

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192010.png)

很明显这种方法不满足对称性，假如我们用如下方法对类型进行判断后比较：

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192251.png)

这种方法确实提供了对称性，但是却牺牲了传递性

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192316.png)

怎么解决呢？事实上，这是面向对象语言中关于等价关系的一个基本问题。我们无法在扩展可实例化的美的同时，既增加新的值组件，同时又保留 equals：约定，除非愿意放弃面向对象的抽象所带来的优势。

虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计（workaround）。根据第 16 条的建议：复合优先于继承。我们不再让 ColorPoint 扩展 Point，而是在 ColorPoint 中加入一个私有的 Point 域，以及一个公有的视图（view）方法。

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192705.png)

* 一致性的例子

一致性（consistency）兴-equals 约定的第四个要求是，如果两个对象相等，它们就必须始终保持相等，除非它们中有一个对象。（或者两个都）被修改了。

无论类是否是不可变的，都不要使 equals 方法依赖于不可靠的资源。如果违反了这条禁令，要想满足一致性的要求就十分困难了。例如，java. Net. URL 的 equals 方法依赖于对 URL 中主机 IP 地址的比较。将一个主机名转变成 IP 地址可能需要访问网络，随着时间的推移，不确保会产生相同的结果。这样会导致 URL 的 equals 方法违反 equals 约定，在实践中有可能引发一些问题。

* 非空性的例子

非空性（Non-nullity）一最后一个要求没有名称，我姑且称它为“非空性（Non- nullity)“，意思是指所有的对象都必须不等于 null。

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192859.png)

为了测试其参数的等同性，equals 方法必须先把参数转换成适当的类型，以便可以调用它的访问方法（acessor），或者访问它的域。在进行转换之前，equals 方法必须使用 instanceof 操作符，检查其参数是否为正确的类型：

![image](http://clsaa-big-data-notes-1252032169.cossh.myqcloud.com/2018-12-16-192937.png)

如果漏掉了这一步的类型检查，并且传递给 equals 方法的参数又是错误的类型，那么 equals 方法将会拋出 ClassCastException 异常，这就违反了 equals 的约定。但是，如果 instanceof 的第一个操作数为 null，那么，不管第二个操作数是哪种类型，instanceof 操作符都指定应该返回 false [JLS，15.20.2]。因此，如果把 null 传给 equals 方法，类型检查就会返回 false，所以不需要单独的 null 检查。

* 高质量equals方法诀窍
  1. 使用==操作符检查“参数是否为这个对象的引用”。如果是，则返回 true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
  2. 使用 instanceof 操作符检查“参数是否为正确的类型”。如果不是，则返回 false。一般说来，所谓“正确的类型”是指 equals 方法所在的那个类。有些情况下，是指该类所实现的某个接口。如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行比较，那么就使用接口。
  3. 把参数转换成正确的类型。因为转换之前进行过 instanceof 测试，所以确保会成功。
  4. 对于该类中的每个“关键（significant)“域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回 true；否则返回 false。
  5. 当你编写完成了 equals 方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？
* 不要这么做：
  * 覆盖 equals 时总要覆盖 hashCode
  * 不要企图让 equals 方法过于智能
  * 不要将 equals 声明中的 Object 对象替换为其他的类型。问题在于，这个方法并没有覆盖 Ojeclequas，因为它的参数应该是 Ojec 类型，相反，它重载（overload）了 Object. Equals。
