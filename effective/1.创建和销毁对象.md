# 1.创建和销毁对象

## 1.1.考虑使用静态工厂方法替代构造器

### 1.1.1.静态工厂方法的优势

* 静态工厂方法与构造器不同的第-大优势在于它们有名称. 
  * 例如，构造器 BigInteger  (int, int, Random）返回的 BigInteger 可能为素数，如果用名为 BigInteger. ProbablePrime 的静态工厂方法来表示，显然更为清楚。
  * 当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重地选择名称以便突出它们之间的区别。
* 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。
  * Boolean.valueOf(boolean）
  * 静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作实例受控的类（instance -controlled）。编写实例受控的类有几个原因。实例受控使得类可以确保它是-一个 Singleton（见第 3 条）或者是不可实例化的（见第 4 条）。它还使得不可变的类（见第 15 条）可以确保不会存在两个相等的实例，即当且仅当 a==b 的时候才有 a. Equals (b）为 ture。'如果类保证了这一点，它的客户端就可以使用==操作符来代替 equals  (Object）方法，这样可以提升性能。枚举（enum）类型（见第 30 条）保证了这一点。
* 静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有了更大的灵活性。
  * 这种灵活性的一种应用是，API 可以返回对象，同时又不会使对象的类变成公有的。
  * 例如，Java Collections Framework 的集合接口有 32 个便利实现，分别提供了不可修改的集合、同步集合等等。几乎所有这些实现都通过静态工厂方法在一个不可实例化的类（java. Util. Collections）中导出。所有返回对象的类都是非公有的。
  * 公有的静态工厂方法所返回的对象的类不仅可以是非公有的，而且该类还可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。只要是已声明的返回类型的子类型，都是允许的。为了提升软件的可维护性和性能，返回对象的类也可能随着发行版本的不同而不同。
  * 发行版本 1.5 中引入的类 java. Util. EnumSet（见第 32 条）没有公有构造器，只有静态工厂方法。它们返回两种实现类之一，具体则取决于底层枚举类型的大小.
  * 静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。这种灵活的静态工厂方法构成了服务提供者框架（Service Provider Framework）的基础，例如 JDBC  (Java 数据库连接，Java Database Connectivity) API。服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把他们从多个实现中解耦出来。

```

```

* 静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁。遗憾的是，在调用参数化类的构造器时，即使类型参数很明显，也必须指明。

### 1.1.2.静态工厂方法的缺点

* 静态工厂方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。
* 