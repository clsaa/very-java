# 1.创建和销毁对象

## 1.1.考虑使用静态工厂方法替代构造器

### 1.1.1.静态工厂方法的优势

* 静态工厂方法与构造器不同的第-大优势在于它们有名称. 
  * 例如，构造器 BigInteger  (int, int, Random）返回的 BigInteger 可能为素数，如果用名为 BigInteger. ProbablePrime 的静态工厂方法来表示，显然更为清楚。
  * 当一个类需要多个带有相同签名的构造器时，就用静态工厂方法代替构造器，并且慎重地选择名称以便突出它们之间的区别。
* 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。
  * Boolean.valueOf(boolean）
  * 静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作实例受控的类（instance -controlled）。编写实例受控的类有几个原因。实例受控使得类可以确保它是-一个 Singleton（见第 3 条）或者是不可实例化的（见第 4 条）。它还使得不可变的类（见第 15 条）可以确保不会存在两个相等的实例，即当且仅当 a==b 的时候才有 a. Equals (b）为 ture。'如果类保证了这一点，它的客户端就可以使用==操作符来代替 equals  (Object）方法，这样可以提升性能。枚举（enum）类型（见第 30 条）保证了这一点。
* 静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有了更大的灵活性。
  * 这种灵活性的一种应用是，API 可以返回对象，同时又不会使对象的类变成公有的。
  * 例如，Java Collections Framework 的集合接口有 32 个便利实现，分别提供了不可修改的集合、同步集合等等。几乎所有这些实现都通过静态工厂方法在一个不可实例化的类（java. Util. Collections）中导出。所有返回对象的类都是非公有的。
  * 公有的静态工厂方法所返回的对象的类不仅可以是非公有的，而且该类还可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。只要是已声明的返回类型的子类型，都是允许的。为了提升软件的可维护性和性能，返回对象的类也可能随着发行版本的不同而不同。
  * 发行版本 1.5 中引入的类 java. Util. EnumSet（见第 32 条）没有公有构造器，只有静态工厂方法。它们返回两种实现类之一，具体则取决于底层枚举类型的大小.
  * 静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。这种灵活的静态工厂方法构成了服务提供者框架（Service Provider Framework）的基础，例如 JDBC  (Java 数据库连接，Java Database Connectivity) API。服务提供者框架是指这样一个系统：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把他们从多个实现中解耦出来。

```

```

* 静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁。遗憾的是，在调用参数化类的构造器时，即使类型参数很明显，也必须指明。

### 1.1.2.静态工厂方法的缺点

* 静态工厂方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。
* 静态工厂方法的第二个缺点在于，它们与其他的静态方法实际上没有任何区别。在 API 文档中，它们没有像构造器那样在 API 文档中明确标识出来，因此，对于提供了静态工厂方法而不是构造器的类来说，要想查明如何实例化一个类，这是非常困难的。Javadoc 工具总有一天会注意到静态工厂方法。同时，你通过在类或者接口注释中关注静态工厂，并遵守标准的命名习惯，也可以弥补这一劣势。下面是静态工厂方法的一些惯用名称：
  * ValucOf-不太严格地讲，该方法返回的实例与它的参数具有相同的值。这样的静态工厂方法实际，上是类型转换方法。
  * of 一 valueOf 的一一种更为简洁的替代，在 EnumSet（见第 32 条）中使用并流行起来。
  * getInstance--返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于 Singleton 来说，该方法没有参数，并返回唯一的实例。
  * newInstance-像 getInstance- 样，但 newInstance 能够确保返回的每个实例都与所有其他实例不同。
  * getType-像 getInstance- -样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型。
  * newType- 像 newInstance-样，但是在工厂方法处于不同的类中的时候使用。Type 表示工厂方法所返回的对象类型。


## 1.2.遇到多个构造器参数时要考虑用构建器

静态工厂和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。考虑用一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必需的：每份的含量、每罐的含量以及每份的卡路里，还有超过 20 个可选域：总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。大多数产品在某几个可选域中都会有非零的值。

如果使用**重叠构造器**(构造器重载), 客户端代码会很难编写，并且仍然较难以阅读。如果读者想知道那些值是什么意思，必须很仔细地数着这些参数来探个究竟。一长串类型相同的参数会导致一些微妙的错误。如果客户端不小心颠倒了其中两个参数的顺序，编译器也不会出错，但是程序在运行时会出现错误的行为。

如果使用**JavaBeans模式**(调用-个无参构造器来创建对象，然后调用 setter 方法来设置每个必要的参数), 这种模式弥补了重叠构造器模式的不足。说得明白一点，就是创建实例很容易，这样产生的代码读起来也很容易. 遗憾的是，JavaBeans 模式自身有着很严重的缺点。因为构造过程被分到了几个调用中，在构造过程中 JavaBean 可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。试图使用处于不一致状态的对象，将会导致失败，这种失败与包含错误的代码大相径庭，因此它调试起来十分困难。与此相关的另一点不足在于，JavaBeans 模式阻止了把类做成不可变的可能，这就需要程序员付出额外的努力来确保它的线程安全。

推荐使用**Builder模式**的一种形式, 不直接生成想要的对象,而是让客户端利用所有必要的参数调用构造器, 得到一个builder对象, 然后客户端在builder对象上调用类似于setter的方法, 来设置每个相关的可选参数. 最后客户端调用无参的build方法来生成不可变的对象. 这个builder是它构建的类的静态成员类.

```java


public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;

    public static class Builder {
        //required parameters

        private final int servingSize;
        private final int servings;

        //Optional parameters

        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int calories){
            this.calories = calories;
            return this;
        }

        public Builder fat(int fat){
            this.fat = fat;
            return this;
        }

        public Builder sodium(int sodium){
            this.sodium = sodium;
            return this;
        }

        public NutritionFacts build(){
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder){
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
        this.sodium = builder.sodium;
    }
}

```

注意 NutritionFacts 是不可变的，所有的默认参数值都单独放在一个地方。builder 的 setter 方法返回 builder 本身，以便可以把调用链接起来。

Builder 像个构造器一样，可以对其参数强加约束条件。build 方法可以检验这些约束条件。将参数从 builder 拷贝到对象中之后，并在对象域而不是 builder 域中对它们进行检验，这一点很重要。如果违反了任何约束条件，build 方法就应该抛出 IllegalStatcExccption。异常的详细信息应该显示出违反了哪个约束条件。

对多个参数强加约束条件的另一种方法是，用多个 setter 方法对某个约束条件必须持有的所有参数进行检查。如果该约束条件没有得到满足，setter 方法就会抛出 IlegalArgumentException。这有个好处，就是一旦传递了无效的参数，立即就会发现约束条件失败，而不是等着调用 build 方法。

与构造器相比，builder 的微略优势在于，builder 可以有多个可变（varargs）参数。构造器就像方法一样，只能有一个可变参数。因为 builder 利用单独的方法来设置每个参数，你想要多少个可变参数，它们就可以有多少个，直到每个 setter 方法都有一个可变参数。

Builder 模式十分灵活，可以利用单个 builder 构建多个对象。builder 的参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。builder 可以自动填充某些域，例如每次创建对象时自动增加序列号。

设置了参数的 builder 生成了一个很好的抽象エ厂换句话说，客户端可以将这样一个 builder 传给方法，使该方法能够为客户端创建一个或者多个对象。要使用这种用法，需要有个类型来表示 builder。如果使用的是发行版本 1.5 或者更新的版本，只要一个泛型就能满足所有的 builder，无论它们在构建哪种类型的对象：

带有 Builder 实例的方法通常利用有限制的通配符类型（bounded wildcard type，见第 28 条）来约束构建器的类型参数。例如，下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树：

```

Tree buildTree(Builder<? extends Node> nodeBuilder){...}

```

Java 中传统的抽象工厂实现是 Clas8 对象，用 newinstance 方法充当 build 方法的一部分。这种用法隐含着许多问题。newinstance“方法总是企图调用类的无参构造器，这个构造器甚至可能根本不存在。如果类没有可以访问的无参构造器，你也不会收到编译时错误。相反，客户端代码必须在运行时处理 Instantiationexception 或者 llegalaccessexception，这样既不雅观也不方便。newinstance。方法还会传播由无参构造器抛出的任何异常，即使 newinstancef 缺乏相应的 throws-子句。换句话说，Class, newinstance 破坏了编译时的异常检查。上面讲过的 Builder 接口弥补了这些不足。